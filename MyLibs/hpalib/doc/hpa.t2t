HIGH PRECISION ARITHMETIC LIBRARY PROGRAMMER'S MANUAL
Copyright (C) 2005 - 2010 Ivano Primi <ivprimi (a) libero (dot) it> 
Last Update: %%mtime(%Y-%m-%d)

Permission  is granted to copy, distribute and/or modify this document under 
the terms of the GNU Free Documentation  License,  Version 1.3 or any later 
version published by the   Free   Software  Foundation;  with  no 
Invariant  Sections,  no Front-Cover  Texts,  and no Back-Cover Texts. 
A copy of the license is included in the
[section "GNU Free Documentation License" #GNUFDL].

=Summary=

The High Precision Arithmetic (HPA) library implements a high
precision floating point arithmetic together with a
comprehensive set of support functions. The general
areas covered by these functions include:

- Extended Precision Arithmetic,
- Extended Precision Math Library,
- Applications of High Precision Computation.


The math library support includes evaluation of
trigonometric, inverse trigonometric, hyperbolic,
logarithm, and exponential functions at the same
precision as the floating point math itself.
The HPA library also supports high precision complex 
arithmetic and includes an Extended Precision 
Complex Math Library.

=License=

The HPA library has been derived 
from a branch of the source code of the CCMath library,
which is a work by Daniel A. Atkinson. 
Since Daniel A. Atkinson released the code of the CCMath Library 
under GNU Lesser General Public License, it has been possible
for Ivano Primi to modify, complete and redistribute this source code 
under the same terms.

The HPA (abbreviation of High Precision Arithmetic) Library is then
copyrighted by Ivano Primi  <ivprimi (at) libero (dot) it>  and
Daniel A. Atkinson. As for the CCMath Library, its source code
is released under the terms of the GNU Lesser General 
Public License, as published by the Free Software Foundation; 
either version 2.1 of the License, or (at your option) any later version.

The HPA library is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public License
along with this library; if not, see  http://www.gnu.org/licenses/.
Write to the email address

	<ivprimi (at) libero (dot) it>                                      .

if you want to ask for additional information, report bugs or submit patches.

=General Technical Comments=

The functions forming the HPA library are all implemented in a portable 
fashion in the C language.
The IEEE 754 standard for floating point hardware and software is assumed
in the PC/Unix version of this library. The normal configuration of the library
employs a floating point mantissa of 112 bits, which corresponds approximately to a 
32 decimal digit precision. Higher precision is available as an option.
An extended floating point number is represented as a combination of the
following elements:
- sign bit(s): 0 -> positive, 1 -> negative ;
- exponent(e): 15-bit biased integer (bias=16383) ;
- mantissa(m): 7 words of 16 bit length with the leading 1 explicitly represented .
-
The range of representable numbers is then given by
```                   2^16384 > x > 2^[-16383]
or
```              1.19*10^4932 > x > 1.68*10^-[4932].
Special values of the exponent are:
- all ones -> infinity (floating point overflow)
- all zeros -> number = zero.
-
Underflow in operations is handled by a flush to zero. Thus, a number with
the exponent zero and nonzero mantissa is invalid (not-a-number).
From the point of view of the HPA library, a complex number is simply
a structure formed by two extended floating point numbers, representing
respectively the real and the imaginary part of the complex number.

=General overview=

The HPA library is composed by //two// //modules//. The first one is formed
by the functions for real arithmetic, i.e. by the functions
operating on real arguments. The second one is formed by all functions
which manipulate complex arguments.
The lists of the functions which compose the HPA library
are in the header files ``xpre.h`` and ``cxpre.h``.
``xpre.h`` is the header file for real arithmetic, it contains the definition
of an extended precision real number (``struct xpr``),
and the declarations of the functions provided by the library
to manipulate real arguments.
The numeric type ``struct xpr`` can be used to declare and define
real variables, just as in
``` struct xpr q;
The size of a variable of type ``struct xpr`` is given by  
(2 x XDIM + 2) bytes, where  ``XDIM`` is a constant defined in the file 
``xpre.h`` (namely, in the file ``hpaconf.h`` which is included by 
``xpre.h``).

``cxpre.h`` is the header file for complex arithmetic, it contains 
the definition of an extended precision complex number 
(``struct cxpr``), and the declarations of the functions supplied
by the library to manipulate complex arguments.
The numeric type ``struct cxpr`` can be used to declare and define
complex variables, just as in
``` struct cxpr q;
The size of a variable of type ``struct cxpr`` is given by  
(4 x XDIM + 4) bytes, where  ``XDIM`` is the same constant as above.

Before declaring or defining variables of type ``struct xpr``
and before using anyone of the functions declared in the header file
``xpre.h``, you have to insert the line
``` #include <xpre.h>
in your source code file.
Similarly, before declaring or defining variables of type ``struct cxpr``
and before using anyone of the functions declared in the header file
``cxpre.h``, you have to add the line
``` #include <cxpre.h>
to your source code file.

After including in your source code the header file ``xpre.h`` or, 
if you also need functions handling complex arguments, the header file 
``cxpre.h``, you can start to use the HPA library
by defining all variables and calling 
all functions which are necessary for your computations.
In fact, the HPA library DOES NOT REQUIRE that a special initialization
routine must be called before any other function of the library.
Moreover, variables of  type ``struct xpr`` or ``struct cxpr``
DO NOT NEED to be initialized before they can be used.

When the HPA library was written, a sort of namespace was created
for all the identifiers used by the library.
This has been achieved by sticking to the following rules:

+ Identifiers of functions and types are lowercase; the unique
exception to this rule is the function ``xisNaN()``. Their names start
by ``x``, if they are defined in ``xpre.h``, or by ``cx``, if they are defined
in ``cxpre.h``, with the only exception of a few functions,
which have a name ending by ``tox`` or ``tocx``: 
``` strtox(), strtocx(), atox(), atocx(),
``` dbltox(), dctocx(), flttox(), fctocx(),
``` inttox(), ictocx(), uinttox(), uctocx();
+ The names of the macros defined by the HPA library are all uppercase
and start by ``X`` or ``CX``;
+ The names of the global constants defined by the HPA library start
by ``x`` (real constants) or by ``cx`` (complex constants) and the letter
which immediately follows this prefix is always uppercase, just as in
``xZero``, ``xPi``, ``cxOne``, ``cxIU`` (``IU`` stays for imaginary
unit);
+ The unique global variable defined by the HPA library is an
error indicator of ``int`` type, whose name is ``xErrNo``.
+
This is a trivial program showing the use of the HPA library:
```

#include <stdio.h>
#include <xpre.h>

int main (void)
{
  struct xpr s;
  int i, n;

  do
    {
      printf ("Give me a number, n = ? \t");
      scanf ("%d", &n);
      s = xZero;
      for (i = 0; i <= n; i++)
        s = xadd (s, xpr2(xOne, i), 0);
      printf ("The sum 2^0 + 2^1 + ... + 2^n is equal to\n");
      xprxpr (s, 30);
      putchar ('\n');
    } while (n > 0);
  return 0;
}

```
This program takes in input from the user an integer value ``n``
and prints on the screen the sum of the first ``n`` powers of ``2``.
In the program we use the functions ``xpr2()`` and ``xprxpr()``.
``xpr2(x, n)``, where ``n`` is an integer, returns ``x* 2^n``, while
``xprxpr(x, m)``, where ``m`` is an integer, prints on the screen
the number ``x`` with ``m`` decimal digits after the decimal point (.) .

The HPA library is **NOT** thread safe. Some of the HPA internal
data could get corrupted if multiple HPA functions are active at the
same time. This is due to the fact that some functions of the HPA library
use static variables to store information.
The user should then guarantee that only one thread is performing
HPA functions. This can usually be achieved by a call to the operating
system to obtain a //semaphore//, //mutex//,  or //critical code section//;
the operating system will then guarantee that only one HPA thread will be
active at a time.

=Dealing with runtime errors=[runtime_errors]

During the use of the HPA library it could happen to pass
to a function an illegal argument, namely, an argument whose
value is not compatible with the mathematical definition of the function.
For example, this occurs when a negative value is passed to
the function ``xsqrt()``. This function computes and returns 
the (real) square root of its argument, but the square root of a number
is defined only for non-negative numbers.
So, if ``x`` is less than zero, ``xsqrt(x)`` can not
be computed and a mathematical error occurs, a so called //domain error//.
Another type of mathematical error occurs when the second argument
of the division function (``xdiv()``) is zero: since it is impossible
to divide a number by zero, a //division by zero// error occurs.
What exactly happens when a mathematical error is detected during the
execution of a function depends on the way the HPA library was compiled
when it was installed on the system where you are working.
If, during the installation process, the default setting was left
unchanged, then, whenever a runtime error occurs within a function of the HPA
library, this function will set an external error indicator to
a suitable value. This value can be looked up later
to know what exactly went wrong.
The name of the variable of type ``int`` used as error indicator
is ``xErrNo``. Before any function of the HPA library is
executed, the value of ``xErrNo`` is ``0``.
If a mathematical error occurs when the first HPA function is called, 
then ``xErrNo`` is set to a suitable positive value,
which indicates the exact type of the error.
After, ``xErrNo`` is modified if and only if, during the execution of
an HPA function, another mathematical error occurs. ``xErrNo`` is never
reset to ``0`` by the HPA library; therefore, in order to detect 
possible errors, one has to
set ``xErrNo`` to zero before calling any function of the HPA library. 
An example of error handling is given by:
```

#include <stdio.h>
#include <xpre.h>

extern int xErrNo;

int main (void)
{
  int n;
  struct xpr sr;

  do
    {
      printf ("Give me a number, n = ? \t");
      scanf ("%d", &n);
      xErrNo = 0;
      sr = xsqrt (inttox (n));
      if (xErrNo == 0)
        {
          printf ("The square root of %d is\n", n);
          xprxpr (sr, 30);
          putchar ('\n');
        }
      else
        fprintf (stderr, "*** Error: Out of domain\n");
    } while (n != 0);
  return 0;
}

```
In this program ``xErrNo`` is reset to zero, at each execution of the
``do {...} while();`` loop, before the call of the ``xsqrt()`` function.

However, the HPA library could be compiled to deal differently with
runtime errors.
For example, in case of error a suitable message could be
printed on //stderr// and the library could also cause the
termination of the calling program via ``exit(1)``.
Finally, the library could also be compiled to ignore
any mathematical error (sigh !). To know how the routines of
the HPA library deal with errors is sufficient to examine the file
``hpaconf.h`` (which is automatically included by ``xpre.h`` and
``cxpre.h``). This file defines the macro:

- ``XERR_DFL``   to mean that, in case of error, 
``xErrNo`` is suitably set;
- ``XERR_WARN``  to mean that, in case of error, 
a suitable message is printed on stderr;
- ``XERR_EXIT``  to mean that, in case of error, 
the calling program is terminated
through a call to ``exit(1)`` after
printing a message on stderr;
- ``XERR_IGN``  to mean that, in case of error, 
nothing is done or signaled.


When the macro ``XERR_DFL`` is defined, the header file ``xpre.h``
also defines the macros ``XENONE``, ``XEDIV``, ``XEDOM``,
``XEBADEXP``, ``XFPOFLOW`` and ``XNERR``:
```
#define XENONE   0    /* No error         */
#define XEDIV    1    /* Division by zero */
#define XEDOM    2    /* Out of domain    */
#define XEBADEXP 3    /* Bad exponent     */
#define XFPOFLOW 4    /* Floating point overflow */

#define XNERR    4    /* Number of the non-null error codes */
```
These macros can be used, together with ``xErrNo``, to recover the exact 
type of the error occurred during the execution of a routine 
of the HPA library.

=Compiling and linking=[comp_link]

Together with the HPA library is installed a little and simple
program called ``hpaconf``. 
You can use it to quickly compile and build your programs.
If PREFIX is the root directory chosen to install the HPA library
(the default value for PREFIX is ``/usr/local``), then ``hpaconf``
should be installed inside PREFIX/bin. You can know where ``hpaconf``
is installed by launching the command
``` which hpaconf
in your console or terminal.
In the following it is assumed that the directory PREFIX/bin
is included in your PATH environment variable (This is surely
true if the command ``which`` was able to find ``hpaconf``).  

``hpaconf`` recognizes four options:

: ``-v`` 
  to return the version of HPA installed on your system,
: ``-c`` 
  to return the flags needed to compile with HPA,
: ``-l`` 
  to return the flags needed to link against HPA,
: ``-n`` 
  to print a newline at the end of the output.
:
The option ``-v`` cannot be used together with the options ``-c`` and ``-l``,
but it may be used together with ``-n``:
``` hpaconf -v
prints on the standard output (console) 
the version of HPA installed on your system,
``` hpaconf -v -n 
or 
``` hpaconf -n -v
(order does not matter) behaves exactly the same but 
also prints a newline to force the following output to be written on the next line.

The options ``-c`` and ``-l`` cannot be used together with ``-v``, but they 
can be used both at the same time and can also be accompanied by the option 
``-n``. Of course, order does not matter.
``` hpaconf -c
prints on the standard output the flags needed to compile with HPA,
``` hpaconf -l
prints on the standard output the flags needed to link  against HPA,
``` hpaconf -c -l 
or 
``` hpaconf -l -c
prints both the flags to compile with HPA and the flags to link against HPA.

If the option ``-n`` is added, then the information printed is followed
by a newline. 
An example will show the usefulness of ``hpaconf``.
To compile the source file ``example.c`` you should tell the compiler 
where looking for the header files of HPA and for the library itself; 
to do this it is sufficient to specify the related paths through the options
-I and -L, at least if you are using GCC/G++ as C/C++ compiler.
But in this way you are constrained to remember the path
where HPA was installed, and this is quite uncomfortable.
With ``hpaconf`` you can simply use the command
``` cc -c $(hpaconf -c) example.c
or
``` cc -c `hpaconf -c` example.c
to compile the file ``example.c`` and obtain the object file ``example.o``.
The previous one is the right form of the command 
for a shell sh compatible, like ash, bash or ksh. 
If you are using another shell, probably the
right form to obtain the expansion of the command ``hpaconf -c``
will be another one (see the manual of your preferred shell for this).
On GNU/Linux, bash is the default shell for all users. If this is
not true for your machine, ask your system administrator.
Once you have obtained the object file ``example.o``, you may do the linkage
by using the command (for a shell sh-compatible):
``` cc example.o $(hpaconf -l) -o example
or

``` cc example.o `hpaconf -l` -o example
If you want, you may also compile and build at the same time by using
``` cc example.c $(hpaconf -c -l) -o example
or
``` cc example.c `hpaconf -c -l` -o example
which will compile ``example.c`` and build the program ``example``.
Naturally, compiling and building at the same time is only
possible when the source code of your program is entirely contained in one
file.

The ``hpaconf`` program may also tell you which options were used 
to compile the HPA library for the system where you are working.
This information is displayed, together with hints about usage, when
``hpaconf`` is called with no options. This is the output obtained
on my personal machine:
```
ivano@darkstar[~]$  hpaconf 
*** Usage:  hpaconf [-v] [-n] or
***         hpaconf [-c] [-l] [-n]

*** Meaning of the options:
    -v      returns the current version of the HPA library,
    -c      returns the flags to compile with HPA library,
    -l      returns the flags to link against HPA library,
    -n      adds a newline at the end of the output.

----- Features of the HPA library (including build options) -----

Size of an extended precision floating point value (in bytes): 16
Number of bits available for the sign:     1
Number of bits available for the exponent: 15
Number of bits available for the mantissa: 112
Decimal digits of accuracy:               ~33
Dynamic range supported:          2^16384 > x > 2^(-16383)   i.e.
                             1.19*10^4932 > x > 1.68*10^-(4932)
In case of floating point error
the global (extern) variable 'xErrNo' is suitably set
```
The first value shown after the header ``Features of the HPA library``
is the size of a variable of ``struct xpr`` type. When I installed the
HPA library on my machine, I chose to compile it by setting ``XDIM``
to 7. Then a variable of type ``struct xpr`` turns out to have a size of
16 = 2 * 7 + 2  bytes.
Since ``XDIM`` could have been set to another value on the system
where you are working (``XDIM`` could also have the values
11, 15, 19, 23, 27 and 31), the first value shown by ``hpaconf``
could differ on your machine.
The next 2 values (bits available for sign and exponent) are
the same for all installations.
The decimal digits of accuracy depend on the value of ``XDIM``,
namely, they increase together with ``XDIM`` till to a maximum of
149 when ``XDIM`` is 31. As you can see, the value of ``XDIM``
determines the accuracy provided by the mathematical functions of 
the HPA library. Even if a larger value for ``XDIM`` implies 
a greater accuracy, together with ``XDIM`` increase the memory
and the time requested by the routines of the HPA library
to perform their computations.

The dynamic range supported by the HPA library is always the same, or almost.
The HPA library can be compiled to deal differently with
the error conditions (see [previous section #runtime_errors]).
In the last line of the output of ``hpaconf``, you can find
information about the way runtime errors are handled.
This information can also be retrieved from the file
``hpaconf.h``, as explained in the previous section.

The file ``hpaconf.h`` also defines the macro HPA_VERSION, a string
containing the version number of the release of the
HPA library currently in use.

=Real arithmetic=[real_arith]

The first module of the HPA library is made of functions for 
Extended Precision Floating Point Arithmetic, functions of the 
Extended Precision Math Library, and of applications of the Extended 
Precision Arithmetic. They are all declared in the file ``xpre.h``
together with some macros and numerical constants.
The header file ``xpre.h`` also defines the structure ``xoutflags``:
```
  struct xoutflags
  {
    short fmt, notat, sf, mfwd, lim;
    signed char padding, ldel, rdel;
  };
```
A structure of such kind is used by the output functions
``xfout()``, ``xout()`` and ``xsout()`` to know how they have to print
numbers.

The field ``notat`` refers to the notation: it can
be equal to ``XOUT_SCIENTIFIC`` (scientific notation) or to ``XOUT_FIXED``
(floating point notation). 

Both ``XOUT_SCIENTIFIC`` and ``XOUT_FIXED`` are
macros defined inside ``xpre.h``.

The field ``sf`` refers to the sign: if ``sf`` is not zero, then every non-negative
number is printed with a plus sign (``+``) ahead.

The field ``mfwd`` indicates the minimum field width to use in
printing numbers. When ``mfwd`` is zero no minimum field width is used.
When ``mfwd`` is negative, then the actual minimum field width is given
by ``-mfwd`` and the printed number is left adjusted on the
field boundary (default is right justification).

``lim`` has a different meaning depending on the notation in use.
Together with the scientific notation, ``lim`` gives the number of
decimal digits to the right of the decimal point
(``lim+1`` = total digits displayed). Otherwise, ``lim + 1`` is the
number of significant digits displayed. When ``lim`` is negative,
the default value (``6``) is used.

Finally, ``padding`` defines the padding character to use together
with a non-zero minimum field width.
If ``padding`` is negative, then the default padding char (i.e. the
blank character) is used.

The fields ``fmt``, ``ldel`` and ``rdel`` are ignored by the functions
``xfout()``, ``xout()`` and ``xsout()``. They are only used by the
functions ``cxfout()``, ``cxout()`` and ``cxsout()`` to
format and print complex numbers.

``fmt`` specifies the format to use in printing complex numbers.
The possible values for ``fmt`` are ``XFMT_STD``, ``XFMT_RAW`` and ``XFMT_ALT``
(these macros are declared inside ``cxpre.h``).
If ``fmt == XFMT_STD``, then the complex number ``(a, b)`` is printed
using the notation ``a+bi`` or ``a-bi`` (depending on the sign of ``b``).
Of course, ``a`` and ``b`` are printed according to the rules
exposed above.
If ``fmt == XFMT_RAW``, then ``(a, b)`` is printed in the form
``` a<two blank spaces>b
just like in
``` 1.0  2.5
assuming that ``a = 1.0`` and ``b = 2.5``.
Finally, if ``fmt == XFMT_ALT``, then ``(a,b)`` is printed
as
``` <left delimiter>a, b<right delimiter>
where <left_delimiter> and <right_delimiter> are the characters
given by the fields ``ldel`` and ``rdel`` respectively.
If ``ldel < 0`` or ``rdel < 0``, then ``(`` or ``)``  is used as
default <left_delimiter> / <right_delimiter>.

Care that none of the functions ``xfout()``, ``xout()``, ``xsout()``,
``cxfout()``, ``cxout()`` or ``cxsout()`` adds a newline at the end
of the printed number.

==Real constants==

The header file ``xpre.h`` defines several constants. Between the
constants defined in ``xpre.h`` there are those ones
corresponding to particular mathematical values:
```
  extern const struct xpr xZero, xOne, xTwo, xTen;
  extern const struct xpr xPinf, xMinf, xNaN;
  extern const struct xpr xPi, xPi2, xPi4, xEe, xSqrt2;
  extern const struct xpr xLn2, xLn10, xLog2_e, xLog2_10, 
                          xLog10_e;
```
xZero (= 0), xOne (= 1), xTwo (= 2)and xTen (= 10) 
do not need a comment.
xPi, xPi2, xPi4, xEe, xSqrt2, xLn2, xLn10, xLog2_e, xLog2_10, xLog10_e
represent, respectively, the values PI (= 3.14159...), PI/2, PI/4,
e (= 2.7182818...), square root of 2 (= 1.4142135...), natural
logarithm of 2 and 10, base-2 logarithm of e and 10, 10-base
logarithm of e.

xPinf, xMinf and xNan are //special values//: xPinf represents the value
``+oo`` (plus infinity), xMinf the value ``-oo`` (minus infinity) and xNaN
is used to mean an invalid number (NaN stays for Not a Number).
xPinf and xMinf are usually returned by a function to signal a
floating point overflow, positive and negative respectively, while
xNaN is returned by the functions converting ASCII strings to floating
point numbers to indicate that the string given to them as argument
does not contain any valid number.
xPinf, xMinf and xNaN should never be used as arguments for functions,
since this has unpredictable results.

==Extended Precision Floating Point Arithmetic==

The arithmetic functions support the basic computations and input/output
operations for extended precision floating point mathematics. Some
of the operations supply capabilities designed to enhance the computational
efficiency of this arithmetic (e.g., ``xpwr``).
What follows is their complete list including the synopsis for each of them.
```
   
```

**xadd** - Add  or subtract two extended precision numbers.

``` struct xpr xadd(struct xpr s,struct xpr t,int f)

- ``s`` = structure containing first number;
- ``t`` = structure containing second number;
- ``f`` = control flag: if 0, then  ``s`` and ``t`` are added,
else they are subtracted (``s-t``).
-
The value returned by ``xadd()`` is the result
of the addition/subtraction. ``xadd()`` can return xPinf or xMinf to
signal a floating point overflow.
-------------------------------------------------------------------------
**xmul** - Multiply two extended precision numbers.

``` struct xpr xmul(struct xpr s,struct xpr t)

- ``s`` = structure containing first number;
- ``t`` = structure containing second number.
-
The value returned by ``xmul()`` is the product ``s*t``. 
It can be xPinf or xMinf in case of overflow.
-------------------------------------------------------------------------
**xdiv** - Divide one extended precision number by a second.

``` struct xpr xdiv(struct xpr s,struct xpr t)

- ``s`` = structure containing numerator;
- ``t`` = structure containing denominator.
-
The value returned by ``xdiv()`` is the quotient ``s/t``.
-------------------------------------------------------------------------
**xneg** - Change sign (unary minus).

``` struct xpr xneg(struct xpr s)

- ``s`` = structure containing input number.
-
The value returned by ``xneg()`` is a structure containing
its argument with the changed sign.
-------------------------------------------------------------------------
**xabs** - Compute absolute value.

``` struct xpr xabs(struct xpr s)

- ``s`` = structure containing input number.
-
The value returned by ``xabs()`` is a structure containing
the absolute value of its argument.
-------------------------------------------------------------------------
**x_exp** - Extract the binary exponent.

``` int x_exp(const struct xpr *p)

- ``p`` = pointer to an extended precision number.
-
The value returned by ``x_exp()`` is the binary exponent 
(power of 2) of the number pointed to by ``p``.
-------------------------------------------------------------------------
**x_neg** - Test the sign of an extended precision number.

``` int x_neg(const struct xpr *p)

- ``p`` = pointer to an extended precision number.
-
The value returned by ``x_neg()`` is a sign flag, with
0 meaning positive input, 1 negative input. The input
is, of course, the number pointed to by ``p``. //Note that//
//neither x_exp() nor x_neg() alter the input number.//
-------------------------------------------------------------------------
**xpwr** - Raise to integer powers.

``` struct xpr xpwr(struct xpr s,int n)

- ``s`` = structure containing input number;
- ``n`` = power desired.
-
The return value is the ``n``th power of the first argument.
-------------------------------------------------------------------------
**xpr2** - Multiplication by a power of 2.

``` struct xpr xpr2(struct xpr s,int m)

- ``s`` = structure containing input number;
- ``m`` = power of two desired.
-
The return value is the product of
the first argument by the ``m``th power of two.
``xpr2()`` returns xZero in case of underflow, xPinf or
xMinf in case of overflow.
-------------------------------------------------------------------------
**xpow** - Power function.

``` struct xpr xpow (struct xpr x, struct xpr y)

- ``x`` = base;
- ``y`` = exponent.
-
The return value is the
power of the first argument raised to the second one.
Note that the first argument must be greater than zero.
-------------------------------------------------------------------------
**xprcmp** - Compare two extended precision numbers.

``` int xprcmp (const struct xpr *p, const struct xpr *q)

- ``p`` = pointer to first number;
- ``q`` = pointer to second number.
-
The value returned by ``xprcmp()`` is a comparison flag, with
 1 meaning ``*p`` greater than ``*q``,  0 meaning ``*p`` equal
to ``*q``, and -1 meaning ``*p`` less than ``*q``. //Note that//
//the input numbers are not altered by xprcmp().//
-------------------------------------------------------------------------
**xeq** - Check if two numbers are or are not equal.

``` int xeq (struct xpr x1, struct xpr x2)

- ``x1`` = first number;
- ``x2`` = second number.
-
The return value is ``0`` if ``x1`` and ``x2`` are different, else a
non-null value.
-------------------------------------------------------------------------
**xneq** - Check if two numbers are or are not equal.

``` int xneq (struct xpr x1, struct xpr x2)

- ``x1`` = first number;
- ``x2`` = second number.
-
The return value is ``0`` if ``x1`` and ``x2`` are equal, else
a non-null value.
-------------------------------------------------------------------------
**xgt** - Check if a number is greater than another one.

``` int xgt (struct xpr x1, struct xpr x2)

- ``x1`` = first number;
- ``x2`` = second number.
-
The return value is ``0`` if ``x1`` is less or equal to ``x2``, 
else a non-null value.
-------------------------------------------------------------------------
**xge** - Check if a number is greater or equal to another one.

``` int xge (struct xpr x1, struct xpr x2)

- ``x1`` = first number;
- ``x2`` = second number.
-
The return value is ``0`` if ``x1`` is less than ``x2``,
else a non-null value.
-------------------------------------------------------------------------
**xlt** - Check if a number is less than another one.

``` int xlt (struct xpr x1, struct xpr x2)

- ``x1`` = first number;
- ``x2`` = second number.
-
The return value is ``0`` if ``x1`` is greater or equal to ``x2``,
else a non-null value.
-------------------------------------------------------------------------
**xle** - Check if a number is less or equal to another one.

``` int xle (struct xpr x1, struct xpr x2)

- ``x1`` = first number;
- ``x2`` = second number.
-
The return value is ``0`` if ``x1`` is greater than ``x2``,
else a non-null value.
-------------------------------------------------------------------------
**xisNaN** - Check if a number is valid or not.

``` int xisNaN (const struct xpr *u)

- ``u`` = pointer to a structure containing a number.
-
The return value is ``0`` if ``*u`` is a valid number,
else a non-null value. 

//Remark://
A number is considered invalid (not-a-number) when its
exponent is zero but not its mantissa.
-------------------------------------------------------------------------
**xisPinf** - Check if a number is equal to ``+oo``.

``` int xisPinf (const struct xpr *u)

- ``u`` = pointer to a structure containing a number.
-
The return value is ``1`` if ``*u`` is equal to
xPinf (``+oo``), ``0`` otherwise.
-------------------------------------------------------------------------
**xisMinf** - Check if a number is equal to ``-oo``.

``` int xisMinf (const struct xpr *u)

- ``u`` = pointer to a structure containing a number.
-
The return value is ``1`` if ``*u`` is equal to
xMinf (``-oo``), ``0`` otherwise.
-------------------------------------------------------------------------
**xisordnumb** - Check if a given number is an ordinary number. 

``` int xisordnumb (const struct xpr *u)

- ``u`` = pointer to a structure containing a number.
-
The return value is ``1`` if ``*u`` is a valid number
and is neither xPinf (``+oo``) nor xMinf (``-oo``),
else ``0``. 
-------------------------------------------------------------------------
**xis0** - Compare a number with zero.

``` int xis0 (const struct xpr *u)

- ``u`` = pointer to a structure containing a number.
-
The return value is ``0`` if ``*u`` is not zero, else a non-zero value.
-------------------------------------------------------------------------
**xnot0** - Compare a number with zero.

``` int xnot0 (const struct xpr *u)

- ``u`` = pointer to a structure containing a number.
-
The return value is ``0`` if ``*u`` is zero, else a non-zero value.
-------------------------------------------------------------------------
**xsgn** - Obtain the sign of a number.

``` int xsgn (const struct xpr *u)

- ``u`` = pointer to a structure containing a number.
-
The return value is ``0`` when ``*u`` is zero or
is an invalid number (not-a-number), ``1`` if ``*u`` is positive,
``-1`` if ``*u`` is negative.

//Remark://
xPinf is considered a positive value, xMinf a negative value.
-------------------------------------------------------------------------
**xtodbl** - Cast extended precision numbers to double precision ones.

``` double xtodbl(struct xpr s)

- ``s`` = structure containing extended precision input.
-
The return value is the double precision float corresponding
to ``s``.
-------------------------------------------------------------------------
**dbltox** - Convert double precision numbers to extended precision ones.

``` struct xpr dbltox(double y)

- ``y`` = double precision floating point input.
-
The return value is a structure containing extended equivalent
of ``y``.
-------------------------------------------------------------------------
**xtoflt** - Cast extended precision numbers to single precision ones.

``` float xtoflt(struct xpr s)

- ``s`` = structure containing extended precision input.
-
The return value is the single precision float corresponding
to ``s``.
-------------------------------------------------------------------------
**flttox** - Convert single precision numbers to extended precision ones.

``` struct xpr flttox(float y)

- ``y`` = single precision floating point input.
-
The return value is a structure containing extended equivalent
of ``y``.
-------------------------------------------------------------------------
**inttox** - Convert signed integers to extended precision numbers.

``` struct xpr inttox(long n)

- ``n`` = integer input.
-
The return value is a structure containing extended equivalent
of ``n``.
-------------------------------------------------------------------------
**uinttox** - Convert unsigned integers to extended precision numbers.

``` struct xpr uinttox(unsigned long n)

- ``n`` = integer input.
-
The return value is a structure containing extended equivalent
of ``n``.
-------------------------------------------------------------------------
**strtox** - Convert a floating point number, 
expressed as a decimal ASCII string
in a form consistent with C, into the extended precision format.

``` struct xpr strtox (const char* s, char** endptr)

- ``s`` = pointer to a null terminated ASCII string expressing a
decimal number;
- ``endptr`` = NULL, or address of a pointer defined
outside ``strtox()``.
-
The value returned by ``strtox()`` is a structure containing
the input number in the extended precision format.

//Remarks://
The ``strtox()`` function converts the initial portion of the string pointed to
by ``s`` to its extended precision representation.

The  expected  form  of  the (initial portion of the) string is: optional
leading white space  as  recognized  by  the standard library function
``isspace()``, an optional plus (``+``) or minus sign (``-``), and 
then a decimal number.
A  decimal number consists of a nonempty sequence of decimal digits possibly
containing a radix character (decimal  point, i.e. '``.``'), optionally
followed by a decimal exponent.   A decimal exponent consists of an
``E`` or ``e``, followed by an optional plus or minus sign, followed  by
a non-empty sequence of decimal digits, and indicates multiplication by
a power of 10.

This function returns the converted value, if any.
If  the  correct  value  would  cause  overflow, then xPinf
or xMinf is returned, according to the sign of the value.
If the correct value would cause underflow, xZero is returned.
If no conversion is performed, xNaN is returned.

If ``endptr`` is not NULL, a pointer to the character after the last character
used  in  the  conversion  is  stored in the location referenced by
``endptr``.
If no conversion is performed, the value of ``s`` is
stored in the location referenced by ``endptr``.
-------------------------------------------------------------------------
**atox** - Convert a floating point number,
expressed as a decimal ASCII string
in a form consistent with C, into the extended precision format.

``` struct xpr atox(const char *s)

- ``s`` = pointer to a null terminated ASCII string expressing a
decimal number.
-

//Remark://
The call  ``atox(s)``  is equivalent to ``strtox(s, NULL)``.
-------------------------------------------------------------------------
**xfmod** - This function is the extended precision analog of the 
``fmod`` function from the C standard library.
     
``` struct xpr xfmod(struct xpr s,struct xpr t,struct xpr* q)

- ``s`` = structure containing argument of fmod;
- ``t`` = structure containing base number (t must be different from zero);
- ``q`` = pointer to store for output integer m.
-      
The return value is the extended number with same sign as ``s``
and absolute value less than that of ``t``, satisfying
``s =  m*t + x``  if ``s*t>0``, or
``s = -m*t + x``  if ``s*t<0``.
-------------------------------------------------------------------------
**xfrexp** - This function is the extended precision analog of the
``frexp`` function from the C standard library.

``` struct xpr xfrexp(struct xpr s,int *p)

- ``s`` = structure containing argument;
- ``p`` = pointer to store for output exponent ``e``.
-      
The return value is the extended number satisfying
``x = s*2^(-e)``  with  ``(-1 < x < +1)``.
-------------------------------------------------------------------------
**xfrac** - This function returns the fractional part of the
input number.

``` struct xpr xfrac  (struct xpr s)
       
- ``s`` = structure containing argument.
-
The return value is the fractional part of the number ``s``, with
the same sign as ``s``.

//Remark://
The fractional part of the number ``s`` is ``0`` if ``s`` is an
integer number, otherwise is given by ``(-)0.xyz...``,  where 
``xyz...``  are the digits of ``s`` following the radix character
(``.``) in the decimal representation. ``xfrac(s)`` has always
the same sign as ``s``.
-------------------------------------------------------------------------
**xtrunc** - This function returns the integer part of the input number.

``` struct xpr xtrunc  (struct xpr s)
       
- ``s`` = structure containing argument.
-
The return value is the integer part of the number ``s``, with
the same sign as ``s``.

//Remark://

The integer part of the number ``s`` is given by  ``(-)xyz...``,  where 
``xyz...``  are the digits of ``s`` before the radix character (``.``) in
its decimal representation.
-------------------------------------------------------------------------
**xfix** - Obtain the integer part of a number (2nd method).

``` struct xpr xfix  (struct xpr s)

- ``s`` = structure containing argument.
-
//Remark://

``xfix()`` is provided as an alternative to ``xtrunc()``. ``xfix()`` tries
to take into account possible rounding errors and cancel their
effects. The use of ``xfix()`` is strongly suggested whenever the argument
is presumed to be an integer number, but it is reasonable to expect 
that some rounding errors make its actual value a bit different from 
that one it should be.
For instance, when ``sizeof(struct xpr) == 64``, on my machine I
obtain

``` xtrunc (xdiv (inttox(100), inttox(100))) == xZero

while the expect result is ``xOne``. This happens since
``xdiv (inttox(100), inttox(100))`` returns a number a bit lower
than ``1``. On the other hand

``` xfix (xdiv (inttox(100), inttox(100))) == xOne .

Since ``xfix()`` introduces another type of rounding error
to give the correct answer in the cases similar to the previous
one, it is not always the right choice.
-------------------------------------------------------------------------
**xround** - Round an extended precision number to its nearest integer 
value (halfway cases are rounded away from zero). 

``` struct xpr xround  (struct xpr s)
       
- ``s`` = structure containing argument.
-
The return value is the integer value nearest to ``s``.
-------------------------------------------------------------------------
**xceil** - Round an extended precision number to the smallest integral 
value not less than it.

``` struct xpr xceil  (struct xpr s)
       
- ``s`` = structure containing argument.
-
The return value is the smallest integral value not less than
the argument.
-------------------------------------------------------------------------
**xfloor** - Round an extended precision number to the largest integral 
value not greater than it.

``` struct xpr xfloor  (struct xpr s)
       
- ``s`` = structure containing argument.
-
The return value is the largest integral value not greater than
the argument.
-------------------------------------------------------------------------
**xpr_print** - Print an extended precision number in scientific or 
floating point format to a given file.

```
void  xpr_print (FILE* stream, struct xpr u, int sc_not, 
                 int sign, int lim)
```

- ``stream`` = file where the number must be printed;
- ``u`` = structure containing number to print;
- ``sc_not`` = zero to mean floating point format, 
not zero to mean scientific format;
- ``sign``   = not zero to put a plus sign (``+``) before the number if
it is non-negative (in case of negative number a minus sign (``-``) 
is printed even if the parameter ``sign`` is zero);
- ``lim``    = number of decimal digits to the right of the
decimal point (``lim+1`` = total digits displayed) in
case of scientific format, otherwise number of significant digits - 1
(``lim+1`` = total of significant digits).
-
-------------------------------------------------------------------------
**xpr_asprint** - Convert an extended precision number to a string.

``` char* xpr_asprint (struct xpr u, int sc_not, int sign, int lim)

- ``u`` = structure containing number to print;
- ``sc_not`` = zero to mean floating point format, not zero to mean scientific format;
- ``sign``   = not zero to put a plus sign (``+``) before the number if
it is non-negative (in case of negative number a minus sign (``-``) 
is printed even if the parameter ``sign`` is zero);
- ``lim``    = number of decimal digits to the right of the
decimal point (``lim+1`` = total digits displayed) in
case of scientific format, otherwise number of significant digits - 1
(``lim+1`` = total of significant digits).
-
``xpr_asprint()`` returns the string with the converted number.
The memory for this string is calloc'ed inside the function.
-------------------------------------------------------------------------
**xprxpr** - Print an extended precision number in scientific format.

``` void xprxpr(struct xpr u,int lim)

- ``u``   = structure containing number to print;
- ``lim`` = number of decimal digits to the right of the
decimal point (``lim+1`` = total digits displayed).
-
//Remark://
``` xprxpr(u, lim)
 
is equivalent to  

``` xpr_print(stdout, u, 1, 0, lim)
-------------------------------------------------------------------------
**xtoa** - This function converts an extended precision number to a 
string. Scientific format is always used.

``` char* xtoa (struct xpr u,int lim)

- ``u``   = structure containing number to print;
- ``lim`` = number of decimal digits to the right of the
decimal point (``lim+1`` = total digits displayed).
-
//Remark://
``` xtoa(u, lim)
 
is equivalent to  

``` xpr_asprint(u, 1, 0, lim)
-------------------------------------------------------------------------
**xbprint** - Print an extended precision number in binary format.

``` void xbprint (FILE* stream, struct xpr u)
       
- ``stream`` = file where the number must be printed;
- ``u``      = structure containing number to print.
-
The ``xbprint()`` function supports a bit oriented analysis of
rounding error effects. It always prints a newline (``\n``)
at the end of the binary string.
-------------------------------------------------------------------------
**xprint** - Print an extended precision number as a string of 
hexadecimal numbers.

``` void xprint(FILE* stream, struct xpr u)

- ``stream`` = file where the number must be printed;
- ``u``      = structure containing number to print.
-
The ``xprint()`` function supports a bit oriented analysis of
rounding error effects. It always prints a newline (``\n``)
at the end.
-------------------------------------------------------------------------
**xfout** - Print an extended precision number on file according to 
a given set of I/O flags.

``` int xfout (FILE * stream, struct xoutflags ofs, struct xpr x)
       
- ``stream`` = file where the number must be printed;
- ``ofs``    = structure containing all I/O flags;
- ``x``      = structure containing number to print.
-
The return value is ``0`` in case of success, 
``-1`` to mean a failure.
     
//Remark:// 
For the definition of ``struct xoutflags`` and the meaning 
of its fields see [section "Real Arithmetic" #real_arith]. 
``xfout()`` does not add any newline 
at the end of the printed number.
-------------------------------------------------------------------------
**xout** - Print an extended precision number on ``stdout`` according to
a given set of I/O flags.

``` int xout (struct xoutflags ofs, struct xpr x)
    
- ``ofs`` = structure containing all I/O flags;
- ``x``   = structure containing number to print.
-
The return value is ``0`` in case of success, ``-1`` to mean a failure.

//Remark:// 
For the definition of ``struct xoutflags`` and the meaning 
of its fields see [section "Real Arithmetic" #real_arith]. 
``xout()`` does not add any newline 
at the end of the printed number.
-------------------------------------------------------------------------
**xsout** - Write an extended precision number on a string according to
a given set of I/O flags.

```
int xsout (char* s, unsigned long n, struct xoutflags ofs,
           struct xpr x)
```

- ``s``   = pointer to a buffer of characters (char);
- ``n``   = size of the buffer;
- ``ofs`` = structure containing all I/O flags;
- ``x``   = structure containing number to print.
-
The return value is the number of non-null characters written
to the buffer or, if it is greater or equal than ``n``, which would have been 
written to the buffer if enough space had been available.

//Remarks://
For the definition of ``struct xoutflags`` and the meaning of its fields
see [section "Real Arithmetic" #real_arith]. 
``xsout()`` always adds a null character ('\0') at the end of 
the written number.
``xsout()`` does not write more than ``n`` bytes (including
the  trailing  '\0'). Thus, a return value of ``n`` or more
means that the output was truncated. In this case, the contents of the 
buffer pointed to by the first argument of ``xsout()`` are 
completely unreliable.


==Extended Precision Math Library==

The Extended Precision Math Library
provides the elementary functions normally
supported in a C math library. 
They are designed to provide full precision accuracy.
```
   
```

**xsqrt** - Compute the square root of an extended precision number.

``` struct xpr xsqrt(struct xpr x)

- ``x`` = structure containing the input number.
-
The return value is the square root of the
input number. A negative argument results in a domain error.
-------------------------------------------------------------------------
**xexp** - Compute the exponential function.

``` struct xpr xexp(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is ``e`` (the base of natural logarithms) 
raised to ``x``.
-------------------------------------------------------------------------
**xexp2** - Compute the base-2 exponential function.

``` struct xpr xexp2(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is ``2`` raised to ``x``.
-------------------------------------------------------------------------
**xexp10** - Compute the base-10 exponential function.

``` struct xpr xexp10(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is ``10`` raised to ``x``.
-------------------------------------------------------------------------
**xlog** - Compute natural (base ``e``) logarithms.

``` struct xpr xlog(struct xpr x)

- ``x`` = structure containing function argument.
-      
This function returns the natural logarithm of
its argument. A null or negative argument results in a
domain error.
-------------------------------------------------------------------------
**xlog2** - Compute base-2 logarithms.

``` struct xpr xlog2(struct xpr x)

- ``x`` = structure containing function argument.
-      
This function returns the base-2 logarithm of
its argument. A null or negative argument results in a
domain error.
-------------------------------------------------------------------------
**xlog10** - Compute base-10 logarithms.

``` struct xpr xlog10(struct xpr x)

- ``x`` = structure containing function argument.
-      
This function returns the base-10 logarithm of
its argument. A null or negative argument results in a
domain error.
-------------------------------------------------------------------------
**xtan** - Tangent function.

``` struct xpr xtan(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is the tangent of ``x``, where ``x`` is
given in radians.
``xtan(x)`` returns ``xPinf`` if ``x`` is equal to ``xPi2``
(up to an integer multiple of ``xPi``),
``xMinf`` if ``x`` is equal to ``-xPi2`` (up to an
integer multiple of ``xPi``). In both cases a
domain error is produced.
-------------------------------------------------------------------------
**xcos** - Cosine function.

``` struct xpr xcos(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is the cosine of ``x``, where ``x`` is
given in radians.
-------------------------------------------------------------------------
**xsin** - Sine function.

``` struct xpr xsin(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is the sine of ``x``, where ``x`` is
given in radians.
-------------------------------------------------------------------------
**xatan** - Arc tangent function.

``` struct xpr xatan(struct xpr x)

- ``x`` = structure containing function argument.
-
This function returns the arc tangent of ``x`` in radians and
the  value  is  mathematically defined to be between -Pi/2
and Pi/2 (inclusive).
-------------------------------------------------------------------------
**xasin** - Arc sine function.

``` struct xpr xasin(struct xpr x)

- ``x`` = structure containing function argument.
-
This function  returns the arc sine of ``x`` in radians and
the value is mathematically defined to  be  between  -Pi/2
and Pi/2 (inclusive). If ``x`` falls outside  the  range
``-1`` to ``1``, a domain error is produced.
-------------------------------------------------------------------------
**xacos** - Arc cosine function.

``` struct xpr xacos(struct xpr x)

- ``x`` = structure containing function argument.
-
This function  returns the arc cosine of ``x`` in radians and
the value is mathematically defined to  be  between zero
and Pi (inclusive). If ``x`` falls outside  the  range
``-1`` to ``1``, a domain error is produced.
-------------------------------------------------------------------------
**xatan2** - arc tangent function of two variables.

``` struct xpr xatan2 (struct xpr y, struct xpr x)

- ``y`` = structure containing first argument;
- ``x`` = structure containing second argument.
-
This function returns the principal value of the arc tangent of ``y/x``, 
using the signs of the two arguments to determine the 
quadrant of the result, a real number in the range ``[-xPi,xPi)``
(``-xPi`` is included, ``xPi`` is excluded). If ``x`` and ``y``
are both zero, a domain error is produced and the dummy value
zero is returned. If ``x`` is zero and ``y`` is positive, then
``xPi2`` (i.e. PI/2) is returned. 
If ``x`` is zero and ``y`` is negative, the function
returns ``-xPi2`` (i.e. -PI/2). 
-------------------------------------------------------------------------
**xtanh** - Hyperbolic tangent function.

``` struct xpr xtanh(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is the hyperbolic tangent of ``x``.
-------------------------------------------------------------------------
**xcosh** - Hyperbolic cosine function.

``` struct xpr xcosh(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is the hyperbolic cosine of ``x``.
-------------------------------------------------------------------------
**xsinh** - Hyperbolic sine function.

``` struct xpr xsinh(struct xpr x)

- ``x`` = structure containing function argument.
-
The return value is the hyperbolic sine of ``x``.
-------------------------------------------------------------------------
**xatanh** - Hyperbolic arc tangent function.

``` struct xpr xatanh(struct xpr x)

- ``x`` = structure containing function argument.
-
This function returns the hyperbolic arc tangent of ``x``.
If the absolute value of ``x``  is  greater  than ``1``,
then a domain error is produced.
-------------------------------------------------------------------------
**xasinh** - Hyperbolic arc sine function.

``` struct xpr xasinh(struct xpr x)

- ``x`` = structure containing function argument.
-
This function  returns the hyperbolic arc sine of ``x``.
-------------------------------------------------------------------------
**xacosh** - Hyperbolic arc cosine function.

``` struct xpr xacosh(struct xpr x)

- ``x`` = structure containing function argument.
-
This function  returns the hyperbolic arc cosine of ``x``.
If ``x`` is less than ``1``, a domain error is produced.

==Applications of Extended Precision Arithmetic==

The Tchebycheff expansion supplied with the library can be used to
compute the Tchebycheff expansion coefficients of a function to an accuracy
of 32 digits at least. This ability is useful in developing high accuracy function
approximations, since the effect of rounding error on coefficients used in
double precision can effectively be eliminated with these inputs.
The functions provided to this purpose are ``xchcof()`` and
``xevtch()``.
```
   
```

**xchcof** - Compute the Tchebycheff expansion coefficients of a 
specified function ``f(x)``.

``` struct xpr* xchcof(int m,struct xpr (*xfunc)(struct xpr))

- ``m`` = index of the last coefficient (the computed coefficients will
be ``m+1``, indexed from ``0`` to ``m``);
- ``xfunc`` = pointer to user defined function returning extended
precision values of the function ``f()``;
-
The return value is the array of the computed coefficients.
The equality
``` f(x) = c[0]/2 + Sum(k=1 to m) c[k]*Tk(x) 
holds, where ``Tk`` is the kth  Tchebycheff polynomial.

//Remarks:// 
The memory needed by the returned array is malloc'ed
inside the function ``xchcof()``. 
To avoid memory leaks it should be explicitly freed through a call to free().
In case of insufficient memory ``xchcof()`` will return NULL.

If ``m <= XMAX_DEGREE (= 50)``, then the array returned by ``xchcof()``
will have exactly ``m+1`` elements, indexed from ``0`` to ``m``.
If ``m > XMAX_DEGREE``, then ``xchcof()`` will behave as if
``m`` were equal to ``XMAX_DEGREE``, namely,
the array returned by ``xchcof()`` will have only 
``XMAX_DEGREE + 1`` elements, indexed from ``0`` to ``XMAX_DEGREE``. 
In other words, a value of ``m`` greater than ``XMAX_DEGREE`` is 
ignored and replaced by ``XMAX_DEGREE``.
``XMAX_DEGREE`` is a macro declared inside the header file
``xpre.h`` .
-------------------------------------------------------------------------
**xevtch** - Evaluate an extended precision Tchebycheff expansion.

``` struct xpr xevtch(struct xpr x,struct xpr *a,int m)

- ``x`` = structure containing function argument;
- ``a`` = structure array containing expansion coefficients;
- ``m`` = maximum index of coefficient array (dimension=``m+1``).
-
The return value is the number given by the formula
``` f(x) = Sum(k=0 to m) a[k]*Tk(x), 
where ``Tk`` is the kth  Tchebycheff polynomial.

=Complex Arithmetic=

The second module of the HPA library is formed by 
functions for Extended Precision Complex Arithmetic and functions 
of the Extended Precision Complex Math Library.
They are all declared in the file ``cxpre.h`` together with some 
macros and numerical constants.

==Complex constants==

The header file ``cxpre.h`` defines the constants
cxZero (= 0), cxOne (= 1) and cxIU (= imaginary unit):
```
  extern const struct cxpr cxZero;
  extern const struct cxpr cxOne;
  extern const struct cxpr cxIU;
```
which require no explanation.

==Extended Precision Complex Arithmetic==

The functions for complex arithmetic support the basic computations
and input/output operations with extended precision complex values.
Some of the functions supply capabilities designed to enhance the 
computational efficiency of the complex arithmetic (e.g., ``cxpwr`` and ``cxpow``). 
What follows is the complete list of the functions 
with related synopses.
```
   
```

**cxreset** - Make a new complex number from its real
and imaginary parts.

``` struct cxpr cxreset (struct xpr re, struct xpr im)

- ``re`` = structure containing real part;
- ``im`` = structure containing imaginary part.
-
The value returned by ``cxreset()`` is the complex
number having ``re`` as its real part, ``im``
as its imaginary part.

//Remark://
``cxreset()`` is also available in the form of a macro:
``` #define CXRESET(re, im) (struct cxpr){re, im}
-------------------------------------------------------------------------
**cxconv** - Convert a real number into a complex one.

``` struct cxpr cxconv (struct xpr x)

- ``re`` = structure containing real part.
-
The value returned by ``cxconv()`` is the complex
number having ``x`` as its real part, zero
as its imaginary part.

//Remark://
``cxconv()`` is also available in the form of a macro:
``` #define CXCONV(x) (struct cxpr){x, xZero}
-------------------------------------------------------------------------
**cxre** - Obtain the real part of a complex number.

``` struct xpr cxre (struct cxpr z)

- ``z`` = structure containing function argument.
-
The value returned by ``cxre(z)`` is the real part of ``z``.

//Remark://
``cxre()`` is also available in the form of a macro:
``` #define CXRE(z) (z).re
-------------------------------------------------------------------------
**cxim** - Obtain the imaginary part of a complex number.

``` struct xpr cxim (struct cxpr z)

- ``z`` = structure containing function argument.
-
The value returned by ``cxim(z)`` is the imaginary part of ``z``.

//Remark://
``cxim()`` is also available in the form of a macro:
``` #define CXIM(z) (z).im
-------------------------------------------------------------------------
**cxswap** - Swap the real and the imaginary part
of a complex number.

``` struct cxpr cxswap (struct cxpr z)

- ``z`` = structure containing function argument.
-
The value returned by ``cxswap(z)`` is the complex
number ``{cxim(z), cxre(z)}``.

//Remark://
``cxswap()`` is also available in the form of a macro:
``` #define CXSWAP(z) (struct cxpr){(z).im, (z).re}
-------------------------------------------------------------------------
**cxconj** - Calculate the complex conjugate of a complex number.

``` struct cxpr cxconj (struct cxpr z)
  
- ``z`` = structure containing function argument.
-
The ``cxconj()`` function returns the complex conjugate value of
its argument, i.e. the value obtained by changing the sign of the
imaginary part.
-------------------------------------------------------------------------
**cxneg** - Change sign (unary minus)

``` struct cxpr cxneg (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxneg(z)`` returns the complex number ``-z``: if
``z = a+ib``, then ``cxneg(z)`` returns ``-a-ib``.
-------------------------------------------------------------------------
**cxinv** - Obtain the reciprocal of a complex number.

``` struct cxpr cxinv (struct cxpr z)

- ``z`` = structure containing function argument.
-
The value returned by ``cxinv()`` is the
reciprocal of its argument. If ``z`` is zero,
then a division-by-zero error is produced.
-------------------------------------------------------------------------
**cxabs** - Calculate the absolute value of a complex number.

``` struct xpr cxabs (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxabs(z)`` returns the absolute value of the complex number ``z``.
The result is a real number.
-------------------------------------------------------------------------
**cxarg** - Calculate the argument of a complex number.

``` struct xpr cxarg (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxarg(z)`` returns the argument or phase angle 
of the complex number ``z``. The result is a real number
in the range ``[-xPi,xPi)`` (``-xPi`` is included, ``xPi`` is excluded).
``cxarg(z)`` is equivalent to ``xatan2(z.im, z.re)``.
-------------------------------------------------------------------------
**cxadd** - Add/subtract two extended precision complex numbers.

``` struct cxpr cxadd (struct cxpr z1, struct cxpr z2, int k)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number;
- ``k`` = control flag: if 0, then  ``z1`` and ``z2`` are added,
else they are subtracted (``z1-z2``).
-
The value returned by ``cxadd()`` is the result
of the addition/subtraction.
-------------------------------------------------------------------------
**cxsum** - Add two extended precision complex numbers.

``` struct cxpr cxsum (struct cxpr z1, struct cxpr z2)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number.
-
The value returned by ``cxsum()`` is the result
of the addition ``z1 + z2``.
-------------------------------------------------------------------------
**cxsub** - Subtract two extended precision complex numbers.

``` struct cxpr cxsub (struct cxpr z1, struct cxpr z2)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number.
-
The value returned by ``cxsub()`` is the result
of the subtraction ``z1 - z2``.
-------------------------------------------------------------------------
**cxmul** - Multiply two extended precision complex numbers.

``` struct cxpr cxmul (struct cxpr z1, struct cxpr z2)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number.
-
The value returned by ``cxmul()`` is the
product ``z1 * z2``.
-------------------------------------------------------------------------
**cxrmul** - Multiply a complex number by a real one.

``` struct cxpr cxrmul (struct xpr c, struct cxpr z)

- ``c`` = structure containing a real number;
- ``z`` = structure containing a complex number.
-
The value returned by ``cxrmul()`` is the
product ``c * z``.
-------------------------------------------------------------------------
**cxdrot** - Multiply a complex number by the imaginary unit.

``` struct cxpr cxdrot (struct cxpr z)

- ``z`` = structure containing function argument.
-
The value returned by ``cxdrot(z)`` is the product of
``z`` times the imaginary unit.
-------------------------------------------------------------------------
**cxrrot** - Multiply a complex number by ``-1i``, where 
``1i`` is the imaginary unit.

``` struct cxpr cxrrot (struct cxpr z)

- ``z`` = structure containing function argument.
-
The value returned by ``cxrrot(z)`` is the product of
``z`` times the negative imaginary unit.
-------------------------------------------------------------------------
**cxdiv** - Divide two extended precision complex numbers.

``` struct cxpr cxdiv (struct cxpr z1, struct cxpr z2)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number.
-
The value returned by ``cxdiv(z1, z2)`` is
the quotient ``z1 / z2``. If ``z2`` is zero, then a
division-by-zero error is produced.
-------------------------------------------------------------------------
**cxgdiv** - Gaussian division between complex numbers having
both real and imaginary part integer.

``` struct cxpr cxgdiv (struct cxpr z1, struct cxpr z2)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number.
-
After eventually rounding ``z1`` and ``z2`` by means of
``cxround()`` (see below), ``cxgdiv(z1, z2)`` returns
the quotient of the gaussian division of ``z1`` by ``z2``. 
If ``z2`` is zero, then a division-by-zero error is produced.

If you do not know what gaussian division means, probably
you will never need this function :)
-------------------------------------------------------------------------
**cxgmod** - Remainder of the Gaussian division.

``` struct cxpr cxgmod (struct cxpr z1, struct cxpr z2)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number.
-
After eventually rounding ``z1`` and ``z2`` by means of
``cxround()`` (see below), ``cxgmod(z1, z2)`` returns
the remainder of the gaussian division of ``z1`` by ``z2``.
If ``z2`` is zero, then a division-by-zero error is produced.

If you do not know what gaussian division means, probably
you will never need this function :)
-------------------------------------------------------------------------
**cxidiv** - Integer division.

``` struct cxpr cxidiv (struct cxpr z1, struct cxpr z2)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number.
-
After eventually rounding ``z1`` and ``z2`` by means of
``cxround()`` (see below), ``cxidiv(z1, z2)`` returns
the quotient of the integer division of ``z1`` by ``z2``.
If ``z2`` is zero, then a division-by-zero error is produced.
``cxidiv()`` is a //smooth// extension of the integer division
between real numbers.
-------------------------------------------------------------------------
**cxmod** - Remainder of the integer division.

``` struct cxpr cxmod (struct cxpr z1, struct cxpr z2)

- ``z1`` = structure containing first number;
- ``z2`` = structure containing second number.
-
After eventually rounding ``z1`` and ``z2`` by means of
``cxround()`` (see below), ``cxmod(z1, z2)`` returns
the remainder of the integer division of ``z1`` by ``z2``.
If ``z2`` is zero, then a division-by-zero error is produced.
-------------------------------------------------------------------------
**cxpwr** - Raise to integer powers.

``` struct cxpr cxpwr (struct cxpr z, int n)

- ``z`` = structure containing input number;
- ``n`` = exponent.
-
The return value is the ``n``th power
of the first argument.
-------------------------------------------------------------------------
**cxpow** - Power function.

``` struct cxpr cxpow (struct cxpr z1, struct cxpr z2)

- ``z1`` = base;
- ``z2`` = exponent.
-
The return value is the power of the first argument
raised to the second one.
Note that the modulus of the first argument must be greater than zero,
if the real part of ``z2`` is less or equal than zero,
otherwise a bad-exponent error is produced.
-------------------------------------------------------------------------
**cxsqr** - Square of a number.

``` struct cxpr cxsqr (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function returns the square of its argument.
-------------------------------------------------------------------------
**cxroot** - ``n``th root of a complex number.

``` struct cxpr cxroot (struct cxpr z, int i, int n)

``cxroot(z,i,n)`` returns the ``i``th branch of
the ``n``th root of ``z``.
If ``n`` is zero or negative and the modulus of ``z`` is zero,
then a bad-exponent error is produced.
-------------------------------------------------------------------------
**cxsqrt** - Principal branch of the square root of a complex number.

``` struct cxpr cxsqrt (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function returns the principal branch of
the square root of its argument.
-------------------------------------------------------------------------
**cxprcmp** - Compare two extended precision complex numbers.

```
struct cxprcmp_res cxprcmp (const struct cxpr* z1,
                            const struct cxpr* z2)
```

- ``z1`` = pointer to first number;
- ``z2`` = pointer to second number.
-
The value returned by ``cxprcmp()`` is a structure formed by two
comparison flags:
```
  struct cxprcmp_res
  {
    int re, im;
  };
```
If the ``.re`` field of the returned structure is:

- +1, then ``z1->re`` is greater than ``z2->re``,
- 0, then ``z1->re`` is equal to ``z2->re``,
- -1, then ``z1->re`` is less than ``z2->re``.
-
The meaning of the ``.im`` field is the same but refers
to ``z1->im`` and ``z2->im``.
//Note that the input numbers are not altered by cxprcmp().//
-------------------------------------------------------------------------
**cxis0** - Compare a complex number with zero.

``` int cxis0 (const struct cxpr* z)

- ``z`` = pointer to an extended precision complex number.
-
The return value is ``0`` if ``*z`` is not zero, else a non-zero value.
-------------------------------------------------------------------------
**cxnot0** - Compare a complex number with zero.

``` int cxnot0 (const struct cxpr* z)

- ``z`` = pointer to an extended precision complex number.
-
The return value is ``0`` if ``*z`` is zero, else a non-zero value.
-------------------------------------------------------------------------
**cxeq** - Check if two complex numbers are or are not equal.

``` int cxeq (struct cxpr z1, struct cxpr z2)

- ``z1`` = first number;
- ``z2`` = second number.
-
The return value is ``0`` if ``z1`` and ``z2`` are different, else a
non-null value.
-------------------------------------------------------------------------
**cxneq** - Check if two complex numbers are or are not equal.

``` int cxneq (struct cxpr z1, struct cxpr z2)

- ``z1`` = first number;
- ``z2`` = second number.
-
The return value is ``0`` if ``z1`` and ``z2`` are equal, else
a non-null value.
-------------------------------------------------------------------------
**cxgt** - Check if a complex number is greater than another one.

``` int cxgt (struct cxpr z1, struct cxpr z2)

- ``z1`` = first number;
- ``z2`` = second number.
-
The return value is ``0`` if ``z1`` is not greater than ``z2``, 
else a non-null value.
-------------------------------------------------------------------------
**cxge** - Check if a complex number is greater or equal to another one.

``` int cxge (struct cxpr z1, struct cxpr z2)

- ``z1`` = first number;
- ``z2`` = second number.
-
The return value is ``0`` if ``z1`` is not greater or equal to ``z2``,
else a non-null value.
-------------------------------------------------------------------------
**cxlt** - Check if a complex number is less than another one.

``` int cxlt (struct cxpr z1, struct cxpr z2)

- ``z1`` = first number;
- ``z2`` = second number.
-
The return value is ``0`` if ``z1`` is not less than ``z2``,
else a non-null value.
-------------------------------------------------------------------------
**cxle** - Check if a complex number is less or equal to another one.

``` int cxle (struct cxpr z1, struct cxpr z2)

- ``z1`` = first number;
- ``z2`` = second number.
-
The return value is ``0`` if ``z1`` is not less or equal to ``z2``,
else a non-null value.
-------------------------------------------------------------------------
**dctocx** - Convert a double precision complex number to
an extended precision number.

``` struct cxpr dctocx (double re, double im)

- ``re`` = real part of the double precision complex number;
- ``im`` = imaginary part of the double precision complex number.
-
The value returned by ``dctocx(re,im)`` is the
extended precision equivalent of the complex number
``(re, im)``.
-------------------------------------------------------------------------
**cxtodc** - Convert an extended precision complex number to
a double precision complex number.

``` void cxtodc (const struct cxpr *z, double *re, double *im)

- ``z`` = pointer to an extended precision complex number;
- ``re`` = pointer to a double precision number;
- ``im`` = pointer to a double precision number.
-
``cxtodc()`` stores in its second and last argument respectively
the real and the imaginary part of the number
pointed to by its first argument.
-------------------------------------------------------------------------
**fctocx** - Convert a single precision complex number to
an extended precision number.

``` struct cxpr fctocx (float re, float im)

- ``re`` = real part of the single precision complex number;
- ``im`` = imaginary part of the single precision complex number.
-
The value returned by ``fctocx(re,im)`` is the
extended precision equivalent of the complex number
``(re, im)``.
-------------------------------------------------------------------------
**cxtofc** - Convert an extended precision complex number to
a single precision complex number.

``` void cxtofc (const struct cxpr *z, float *re, float *im)

``z`` = pointer to an extended precision complex number;

- ``re`` = pointer to a single precision number;
- ``im`` = pointer to a single precision number.
-
``cxtofc()`` stores in its second and last argument respectively 
the real and the imaginary part of the number
pointed to by its first argument.
-------------------------------------------------------------------------
**ictocx** - Convert an integer complex number to
an extended precision number.

``` struct cxpr ictocx (long re, long im)

- ``re`` = real part of the integer complex number;
- ``im`` = imaginary part of the integer complex number.
-
The value returned by ``ictocx(re,im)`` is the
extended precision equivalent of the complex number
``(re, im)``.
-------------------------------------------------------------------------
**uctocx** - Convert an integer complex number to
an extended precision number.

``` struct cxpr uctocx (unsigned long re, unsigned long im)

- ``re`` = real part of the integer complex number;
- ``im`` = imaginary part of the integer complex number.
-
The value returned by ``uctocx(re,im)`` is the
extended precision equivalent of the complex number
``(re, im)``.
-------------------------------------------------------------------------
**strtocx** - Convert a floating point complex number,
expressed as a decimal ASCII string
in a form consistent with C, into the extended precision format.

``` struct cxpr strtocx (const char *s, char **endptr)

- ``s`` = pointer to a null terminated ASCII string expressing a
complex number;
- ``endptr`` = NULL or address of a pointer defined
outside ``strtocx()``.
-
The value returned by ``strtocx()`` is
the input number in extended precision format.

//Remarks://
The ``strtocx()`` function converts the initial portion of 
the string pointed to
by ``s`` to its extended precision representation.

The  expected  form  of  the (initial portion of the) string is optional
leading white space  as  recognized  by  the standard library function
``isspace()``, an optional plus (``+``) or minus sign (``-``) and 
then a decimal number.
A  decimal number consists of a nonempty sequence of decimal digits possibly
containing a radix character (decimal  point, i.e. '``.``'), optionally
followed by a decimal exponent.   A decimal exponent consists of an
``E`` or ``e``, followed by an optional plus or minus sign, followed  by
a non-empty sequence of decimal digits, and indicates multiplication by
a power of 10.

After this decimal number there can be an ``i`` character or,
alternatively, some optional white spaces,
an optional plus (``+``) or minus sign (``-``) and 
then another decimal number followed by an ``i`` character.
Examples of valid representations of complex numbers are:

``"12"``,``"34.56"``,``".7895i"``,``"-34.56-7.23i"``,
``"-45.7   +23.4i"``.

This function returns the converted value, if any.
If  the  correct  value for the real or/and
the imaginary part  would  cause  overflow, then xPinf
or xMinf is returned in the corresponding field, 
according to the sign of the value.
If the correct value would cause underflow, xZero is returned.
If no conversion is performed, xNaN is returned.

If ``endptr`` is not NULL, a pointer to the character after the last character
used  in  the  conversion  is  stored in the location referenced by
``endptr``.
If no conversion is performed, the value of ``s`` is
stored in the location referenced by ``endptr``.
-------------------------------------------------------------------------
**atocx** - Convert a floating point complex number,
expressed as a decimal ASCII string
in a form consistent with C, into the extended precision format.

``` struct cxpr atocx (const char *s)

- ``s`` = pointer to a null terminated ASCII string expressing a
complex number.
-
The return value is the input number converted to the
extended precision format.

//Remark://
The call  ``atocx(s)``  is equivalent to ``strtocx(s, NULL)``.
-------------------------------------------------------------------------
**cxpr_asprint** - Convert an extended precision complex 
number to a string.

```
char *cxpr_asprint (struct cxpr z, int sc_not, int sign,
                    int lim)
```

- ``z`` = structure containing number to print;
- ``sc_not`` = zero to mean floating point notation, not zero to mean scientific notation;
- ``sign``   = not zero to put a plus sign (``+``) before the real part 
of the number if it is non-negative (in case of negative real part 
a minus sign (``-``) is printed even if the parameter ``sign`` is zero);
- ``lim``    = number of decimal digits to the right of the
decimal point (``lim+1`` = total digits displayed) in
case of scientific notation, else number of significant digits - 1
(``lim+1`` = total of significant digits).
-
``cxpr_asprint()`` returns the string with the converted number.
The memory for this string is calloc'ed inside the function.
``cxpr_asprint()`` uses always the format ``"a+bi"`` in
the conversion. 
-------------------------------------------------------------------------
**cxtoa** - This function converts an extended precision complex
number to a string.
Scientific notation is always used for both real and imaginary part.

``` char *cxtoa (struct cxpr z, int lim)

- ``z``   = structure containing number to print;
- ``lim`` = number of decimal digits to the right of the
decimal point (``lim+1`` = total digits displayed).
-
//Remark://
``` cxtoa(z, lim)
is equivalent to  
``` cxpr_asprint(z, 1, 0, lim)
-------------------------------------------------------------------------
**cxfrac** - Fractional part of both real and imaginary part.

``` struct cxpr cxfrac (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxfrac(z)`` returns ``{xfrac(z.re), xfrac(z.im)}``.
-------------------------------------------------------------------------
**cxtrunc** - Integer part of both real and imaginary part.

``` struct cxpr cxtrunc (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxtrunc(z)`` returns ``{xtrunc(z.re), xtrunc(z.im)}``.
-------------------------------------------------------------------------
**cxfix** - Integer part of both real and imaginary part (2nd method).

``` struct cxpr cxfix (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxfix(z)`` returns ``{xfix(z.re), xfix(z.im)}``.
-------------------------------------------------------------------------
**cxround** - Rounding real and imaginary part
to the nearest integer values 
(halfway cases are rounded away from zero).

``` struct cxpr cxround (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxround(z)`` returns ``{xround(z.re), xround(z.im)}``.
-------------------------------------------------------------------------
**cxfloor** - Rounding real and imaginary part
to the largest integral values not greater than them. 

``` struct cxpr cxfloor (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxfloor(z)`` returns ``{xfloor(z.re), xfloor(z.im)}``.
-------------------------------------------------------------------------
**cxceil** - Rounding real and imaginary part
to the smallest integral values not less than them.

``` struct cxpr cxceil (struct cxpr z)

- ``z`` = structure containing function argument.
-
``cxceil(z)`` returns ``{xceil(z.re), xceil(z.im)}``.
-------------------------------------------------------------------------
**cxpr_print** - Print an extended precision complex number 
in scientific or floating point notation to a given file.

```
void cxpr_print (FILE * stream, struct cxpr z, int sc_not,
                 int sign, int lim)
```

- ``stream`` = file where the number must be printed;
- ``z`` = structure containing number to print;
- ``sc_not`` = zero to mean floating point notation, not zero to mean scientific notation;
- ``sign``   = not zero to put a plus sign (``+``) before the real part 
of the number if it is non-negative (in case of negative real part 
a minus sign (``-``) is printed even if the parameter ``sign`` is zero);
- ``lim``    = number of decimal digits to the right of the
decimal point (``lim+1`` = total digits displayed) in
case of scientific notation, else number of significant digits - 1
(``lim+1`` = total of significant digits).
-
-------------------------------------------------------------------------
**cxprcxpr** - Print an extended precision complex number
in scientific notation.

``` void cxprcxpr (struct cxpr z, int m)

- ``z``   = structure containing number to print;
- ``lim`` = number of decimal digits to the right of the
decimal point (``lim+1`` = total digits displayed).
-
//Remark://
``` cxprcxpr(z, lim)
is equivalent to  
``` cxpr_print(stdout, z, 1, 0, lim)
-------------------------------------------------------------------------
**cxprint** - Print an extended precision complex number as a couple
of strings of hexadecimal numbers.

``` void cxprint (FILE * stream, struct cxpr z)

- ``stream`` = file where the number must be printed;
- ``z``      = structure containing number to print.
-
The ``cxprint()`` function supports a bit oriented analysis of
rounding error effects. It always prints a newline (``\n``)
at the end.
-------------------------------------------------------------------------
**cxfout** - Print an extended precision complex number to a file 
according to a given set of I/O flags.

``` int cxfout (FILE * stream, struct xoutflags ofs, struct cxpr z)
       
- ``stream`` = file where the number must be printed;
- ``ofs``    = structure containing all I/O flags;
- ``z``      = structure containing number to print.
-
The return value is ``0`` in case of success, 
``-1`` to mean a failure.
     
//Remark:// 
For the definition of ``struct xoutflags`` and the meaning 
of its fields see [section "Real Arithmetic" #real_arith]. 
``cxfout()`` does not add any newline 
at the end of the printed number.
-------------------------------------------------------------------------
**cxout** - Print an extended precision complex number on ``stdout`` 
according to a given set of I/O flags.

``` int cxout (struct xoutflags ofs, struct cxpr z)
    
- ``ofs`` = structure containing all I/O flags;
- ``z``   = structure containing number to print.
-
The return value is ``0`` in case of success, ``-1`` to mean a failure.

//Remark:// 
For the definition of ``struct xoutflags`` and the meaning 
of its fields see [section "Real Arithmetic" #real_arith].
``cxout()`` does not add any newline 
at the end of the printed number.
-------------------------------------------------------------------------
**cxsout** - Write an extended precision complex number on a string
according to a given set of I/O flags.

```
unsigned long cxsout (char *s, unsigned long n,
                      struct xoutflags ofs, struct cxpr z)
```

- ``s``   = pointer to a buffer of characters (char);
- ``n``   = size of the buffer;
- ``ofs`` = structure containing all I/O flags;
- ``z``   = structure containing number to print.
-
The return value is the number of the non-null characters written
to the buffer or, if it is greater or equal than ``n``, which would have been 
written to the buffer if enough space had been available.

//Remark://
For the definition of ``struct xoutflags`` and the meaning of its fields
see [section "Real Arithmetic" #real_arith]. 
``cxsout()`` always adds a null character ('\0') at the end of 
the written number.
``cxsout()`` does not write more than ``n`` bytes (including
the  trailing  '\0'). Thus, a return value of ``n`` or more
means that the output was truncated. In this case, the contents of the 
buffer pointed to by the first argument of ``cxsout()`` are 
completely unreliable.

==Extended Precision Complex Math Library==

The Extended Precision Complex Math Library 
provides the elementary functions normally
supported in a complex math library. 
They are designed to provide full precision accuracy. 
```
   
```

**cxexp** - Compute the complex exponential function.

``` struct cxpr cxexp (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is ``e`` (the base of natural logarithms) 
raised to ``z``.
-------------------------------------------------------------------------
**cxexp2** - Compute the base-2 complex exponential function.

``` struct cxpr cxexp2 (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is ``2`` raised to ``z``.
-------------------------------------------------------------------------
**cxexp10** - Compute the base-10 complex exponential function.

``` struct cxpr cxexp10 (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is ``10`` raised to ``z``.
-------------------------------------------------------------------------
**cxlog** - Compute natural (base ``e``) logarithm of a complex number.

``` struct cxpr cxlog (struct cxpr z)

- ``z`` = structure containing function argument.
-      
This function returns the natural logarithm of
its argument. A null argument results in a
domain error.
The imaginary part of the result lies in the interval
``[-xPi,xPi)`` (``-xPi`` is included, ``xPi`` is excluded).
-------------------------------------------------------------------------
**cxlog2** - Compute base-2 logarithm of a complex number.

``` struct cxpr cxlog2 (struct cxpr z)

- ``z`` = structure containing function argument.
-      
This function returns the base-2 logarithm of
its argument. A null argument results in a
domain error.
-------------------------------------------------------------------------
**cxlog10** - Compute base-10 logarithm of a complex number.

``` struct cxpr cxlog10 (struct cxpr z)

- ``z`` = structure containing function argument.
-      
This function returns the base-10 logarithm of
its argument. A null argument results in a
domain error.
-------------------------------------------------------------------------
**cxlog_sqrt** - Compute natural (base ``e``) logarithm of the
principal branch of the square root of a complex number.

``` struct cxpr cxlog_sqrt (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function returns the natural logarithm of
the principal branch of the square root of its argument. 
A null argument results in a domain error.
The imaginary part of the result lies in the range
``[-xPi2,xPi2)`` (``-xPi2`` is included, ``xPi2`` is excluded).
-------------------------------------------------------------------------
**cxtan** - Complex tangent function.

``` struct cxpr cxtan (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is the tangent of the complex number ``z``.
``cxtan(z)`` yields a domain error if the imaginary
part of ``z`` is null and the real part is equal,
up to an integer multiple of ``xPi``, to ``xPi2``.
-------------------------------------------------------------------------
**cxcos** - Complex cosine function.

``` struct cxpr cxcos (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is the cosine of the complex number ``z``.
-------------------------------------------------------------------------
**cxsin** - Complex sine function.

``` struct cxpr cxsin (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is the sine of the complex number ``z``.
-------------------------------------------------------------------------
**cxatan** - Complex arc tangent function.

``` struct cxpr cxatan (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function returns the arc tangent of the complex 
number ``z``, i.e. a number ``w`` such that
``z = tan(w)``.
If the real part of ``z`` is null and the
imaginary part is equal to ``+1`` or ``-1``,
then a domain error is produced.
-------------------------------------------------------------------------
**cxasin** - Complex arc sine function.

``` struct cxpr cxasin (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function returns the arc sine of the complex 
number ``z``, i.e. a number ``w`` such that
``z = sin(w)``.
-------------------------------------------------------------------------
**cxacos** - Complex arc cosine function.

``` struct cxpr cxacos (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function returns the arc cosine of the complex 
number ``z``, i.e. a number ``w`` such that
``z = cos(w)``.
-------------------------------------------------------------------------
**cxtanh** - Complex hyperbolic tangent function.

``` struct cxpr cxtanh (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is the hyperbolic tangent
of the complex number ``z``.
``cxtanh(z)`` yields a domain error if the real
part of ``z`` is null and the imaginary part is equal,
up to an integer multiple of ``xPi``, to ``xPi2``.
-------------------------------------------------------------------------
**cxcosh** - Complex hyperbolic cosine function.

``` struct cxpr cxcosh (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is the hyperbolic cosine of 
the complex number ``z``.
-------------------------------------------------------------------------
**cxsinh** - Complex hyperbolic sine function.

``` struct cxpr cxsinh (struct cxpr z)

- ``z`` = structure containing function argument.
-
The return value is the hyperbolic sine of 
the complex number ``z``.
-------------------------------------------------------------------------
**cxatanh** - Complex hyperbolic arc tangent function.

``` struct cxpr cxatanh (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function returns the hyperbolic arc tangent of 
the complex number ``z``, i.e. a number ``w`` such that
``z = tanh(w)``.
If the imaginary part of ``z`` is null and the
real part is equal to ``+1`` or ``-1``,
then a domain error is produced.
-------------------------------------------------------------------------
**cxasinh** - Complex hyperbolic arc sine function.

``` struct cxpr cxasinh (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function  returns the hyperbolic arc sine of 
the complex number ``z``, i.e. a number ``w`` such that
``z = sinh(w)``.
-------------------------------------------------------------------------
**cxacosh** - Complex hyperbolic arc cosine function.

``` struct cxpr cxacosh (struct cxpr z)

- ``z`` = structure containing function argument.
-
This function  returns the hyperbolic arc cosine of 
the complex number ``z``, i.e. a number ``w`` such that 
``z = cosh(w)``.
-------------------------------------------------------------------------
```

```
//FINAL REMARK://
The header file ``cxpre.h`` also defines the macros
``cxconvert``, ``cxdiff``, ``cxprod`` and ``cxipow``:
```
#define cxconvert cxconv
#define cxdiff cxsub
#define cxprod cxmul
#define cxipow cxpwr
```
This allows to use ``cxconvert`` as synonym of ``cxconv``,
``cxdiff`` as synonym of ``cxsub``, ``cxprod`` in place
of ``cxmul``, and ``cxipow`` for ``cxpwr``.

=The C++ interface=

The HPA library supplies a C++ wrapper allowing to
perform high precision computations with the
same syntax of the normal code.
Using the C++ wrapper permits you to write things like:

```
// Compute the factorial of the integer n

xreal factorial(xreal n)
{
        xreal i;
        xreal product = 1;
        for (i=2; i <= n; i++)
                product *= i;
        return product;
}
```
Technically, the C++ wrapper is contained in a separate
library. However, this module is distributed together
with the HPA library as an extension to it.
This section of the manual describes 
the C++ interface of this extension.
This one is formed by two classes, called ``xreal``
and ``xcomplex`` respectively.
The type ``xreal`` can be used to declare or define
real variables. In addition, it defines the mathematical
operations and functions which can be used with them.
The same is for the type ``xcomplex`` with respect to
complex variables and their manipulation. 
Once you have variables of ``xreal`` and ``xcomplex`` type,
you can use the usual C++ syntax, but all computations 
will be performed with the high precision math library. 
Of course, this possibility
greatly simplifies the writing of code.
Note the difference between 

```
struct xpr x, y;
char buffer[256];

while ( (fgets (buffer, 256, stdin)) )
{
  x = atox (buffer);
  printf ("The square root of 2 * %s + 1 is ", buffer);
  y = xadd (xpr2(x, 1), xOne, 0);
  xprxpr (xsqrt (y), 30);
  putchar ('\n');
}
```
and its C++ version:

```
xreal x;

while ( x.getfrom(cin) > 0 )
  cout << "The square root of 2 * " << x << " + 1 is " 
       << sqrt(2 * x + 1) << endl;
```
which is much more compact and easier to understand.

The use of the C++ wrapper requires however a recent
and ANSI-compliant C++ compiler (for instance g++ 3.x).
Moreover, before declaring or defining variables of ``xreal``
type and before using anyone of the functions or operators 
declared in the header file ``xreal.h``, you have to insert the line
``` #include <xreal.h>
in your source code file.

Similarly, before declaring or defining variables of ``xcomplex``
type and before using anyone of the functions or operators
declared in the header file ``xcomplex.h``, you have to add the line
``` #include <xcomplex.h>
to your source code file.

After that, it is recommendable to add the directive
``` using namespace HPA;
since all objects of the C++ wrapper are declared
or defined within the namespace ``HPA``.
Alternatively, you should always use the prefix
``HPA::`` in front of any identifiers coming
from the files ``xreal.h`` or ``xcomplex.h``.
One has to tell the compiler indeed, where it has to look for
the classes ``xreal``, ``xcomplex`` and the related stuff.

This code comes from a real program:

```
#include<iostream>
#include<xreal.h>
using namespace HPA;

int main (void)
{
  xreal x;

  while ( x.getfrom(cin) > 0 )
    cout << "The square root of 2 * " << x << " + 1 is " 
         << sqrt(2 * x + 1) << endl;
  return 0;
}
```
The header files ``xreal.h`` and
``xcomplex.h`` make also directly available the standard classes
``ostream``, ``istream`` and ``string``
(see [sections "The xreal class" #xreal_class]
 and ["The xcomplex class" #xcomplex_class]). 

=Compiling and linking with the C++ wrapper=

Whenever you have to compile and build a program making use
of the C++ wrapper for the HPA library, you can do it by following
the same instructions given in the [section "Compiling and linking" #comp_link],
just take care to use ``hpaxxconf`` in place of
``hpaconf``, as in
``` c++ -c $(hpaxxconf -c) example.cc

``` c++ -c `hpaxxconf -c` example.cc
to compile the file ``example.cc`` and obtain the object file ``example.o``,
or in
``` c++ example.o $(hpaxxconf -l) -o example

``` c++ example.o `hpaxxconf -l` -o example
to do the linkage.
If you want, you may also compile and build at the same time by using
``` c++ example.cc $(hpaxxconf -c -l) -o example

``` c++ example.cc `hpaxxconf -c -l` -o example
All these examples assume that you are working
with bash or with another shell sh-compatible.
In any case, the synopsis of ``hpaxxconf`` is the same of ``hpaconf``.

//Warning://
The command ``hpaxxconf`` is available only if
the C++ wrapper was also built when the HPA library was installed on 
the system where you are working.
It is possible to install the HPA library without
its C++ wrapper. In this case, if you try to launch
the command ``hpaxxconf``, the shell will print
the error message ``"Command not found"`` or
something similar.

=The xreal class=[xreal_class]

The interface of the ``xreal`` class is
contained in the header file ``xreal.h``,
whose contents you can find here together
with the necessary explanations.

%!include: ``xreal.h``

=The xcomplex class=[xcomplex_class]

The interface of the ``xcomplex`` class is
contained in the header file ``xcomplex.h``,
whose contents you can find here together
with the necessary explanations.

%!include: ``xcomplex.h``

=Acknowledgments=

A big thanks to Daniel A. Atkinson,
since without his work the HPA library would not exist.
I have also to thank Aurelio Marinho Jargas 
<verde (at) aurelio (dot) net>, author of txt2tags 
(http://txt2tags.sf.net), a free (GPL'ed) and wonderful
text formatting and conversion tool, 
which I used extensively in writing this manual
and the web page of the HPA library.

Last but not least, I want to thank all the
people till now involved in the Free Software
community, starting from those ones directly involved
in the GNU project (http://www.gnu.org).

=GNU Free Documentation License=[GNUFDL]

%!include: ``FDL.txt``
